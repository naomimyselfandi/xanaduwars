{
  "eventTypes": [],
  "queryTypes": [
    {
      "name": "GetFirepowerModifier",
      "properties": ["attacker", "target", "weapon"],
      "defaultValue": 1.0
    },
    {
      "name": "GetDefenseModifier",
      "properties": ["target", "attacker", "weapon"],
      "defaultValue": 0.0
    }
  ],
  "globalRules": [
    {
      "on": "ReadyState",
      "when": "value // don't override previous rejections",
      "then": "actor.asPlayer == $.activePlayer"
    },
    {
      "on": "ReadyState",
      "when": "value // don't override previous rejections",
      "then": "actor.activeAbilities.empty"
    },
    {
      "on": "Preflight",
      "when": "value // don't override previous rejections",
      "then": "actor.abilities.contains(ability)"
    },
    {
      "on": "Preflight",
      "when": "value // don't override previous rejections",
      "then": [
        "#isMovement = @equals.bind(Move) // method reference",
        "#active = actor.activeAbilities.stream",
        "return(isMovement(ability) ? active.noneMatch(@equals.bind(Move)) : active.allMatch(@equals.bind(Move)))"
      ]
    },
    {
      "on": "CanPassOver",
      "when": "value // don't override previous rejections",
      "then": "traveller.isAlly(obstacle)"
    }
  ],
  "libraries": {
    "Combat": [
      "def _getDamageValue(attacker, target, weapon):",
      "  #base = weapon.damage.max(target)",
      "  (base == null) && return(0)",
      "  #firepower = $.evaluate(GetFirepowerModifier(attacker, target, weapon))",
      "  #defense = $.evaluate(GetDefenseModifier(target, attacker, weapon))",
      "  #multiplier = firepower - defense",
      "  return(T(Math).round(base * multiplier).intValue)",
      "end",
      "",
      "def canFire(attacker, target, weapon):",
      "  (_getDamageValue(attacker, target, weapon) > 0) || return(false)",
      "  #distance = attacker.getDistance(target)",
      "  return((distance >= weapon.minRange) && (distance <= weapon.maxRange))",
      "end",
      "",
      "def fire(attacker, target):",
      "  #damage = attacker.weapons.stream.mapToInt(_getDamageValue.bind(attacker, target)).max.orElseThrow()",
      "  target.hp = target.hp - damage",
      "end"
    ]
  },
  "abilityTags": [],
  "actions": [
    {
      "name": "Move",
      "target": "path",
      "effect": [
        "#obstacle = null",
        "#path = target.iterator",
        "label loop:",
        "  path.hasNext() ? (#tile = path.next()) : goto(done)",
        "  obstacle = tile.unit",
        "  goto((obstacle == null) ? empty_tile : obstacle_exists)",
        "  label empty_tile:",
        "    actor.location = tile",
        "    goto(loop)",
        "  label obstacle_exists:",
        "    $.evaluate(CanPassOver(actor, obstacle)) || return(false) // the unit got stuck",
        "    goto(loop)",
        "label done:",
        "  // if there's a unit on the final tile, the actor boards it, or gets stuck if unable",
        "  (obstacle == null) && return(true)",
        "  $.evaluate(CanBoard(actor, obstacle)) || return(false)",
        "  unit.location = obstacle"
      ]
    },
    {
      "name": "Fire",
      "target": "unit.enemy",
      "filter": "actor.weapons.stream.anyMatch(Combat.canFire.bind(actor, target))",
      "effect": "Combat.fire(actor, target)"
    },
    {
      "name": "Drop",
      "target": "tile[1,1].visible",
      "filter": "(target.unit == null) && $.evaluate(new GetMovementCostQuery(actor.unit, target)).finite",
      "effect": "actor.unit.setLocation(target)"
    }
  ],
  "spells": [
    {
      "name": "AttackUp",
      "focusCost": 300,
      "effect": ["// no direct effect"],
      "rules": [
        {
          "on": "GetFirepowerModifier",
          "then": "value + 0.1"
        }
      ]
    },
    {
      "name": "DefenseUp",
      "focusCost": 300,
      "effect": ["// no direct effect"],
      "rules": [
        {
          "on": "GetDefenseModifier",
          "then": "value + 0.1"
        }
      ]
    }
  ],
  "buildTarget": "tile[1,1].visible",
  "buildFilter": [
    "def matches(tag):",
    "  return(target.movementTable.containsKey(tag))",
    "end",
    "",
    "return((target.unit == null) && unitType.tags.stream.anyMatch(matches))"
  ],
  "buildEffect": "target.createUnit(unitType, actor.owner)",
  "moveAbility": "Move",
  "fireAbility": "Fire",
  "dropAbility": "Drop",
  "commanders": [
    {
      "name": "Alice",
      "signatureSpells": ["AttackUp"],
      "chosenSpells": 0
    },
    {
      "name": "Bob",
      "signatureSpells": ["DefenseUp"],
      "chosenSpells": 0
    }
  ],
  "tileTags": [],
  "tileTypes": [
    {
      "name": "Land",
      "movementTable": {"LandUnit": 1}
    },
    {
      "name": "Water",
      "movementTable": {"WaterUnit": 1}
    }
  ],
  "unitTags": ["LandUnit", "WaterUnit"],
  "unitTypes": [
    {
      "name": "Blob",
      "tags": ["LandUnit"],
      "speed": 3,
      "perception": 2,
      "maxHp": 60,
      "supplyCost": 100,
      "weapons": [
        {
          "name": "Gun",
          "damage": {"LandUnit": 20}
        }
      ]
    },
    {
      "name": "Boat",
      "tags": ["WaterUnit"],
      "speed": 6,
      "perception": 2,
      "maxHp": 80,
      "supplyCost": 100,
      "aetherCost": 50,
      "hangar": "LandUnit"
    },
    {
      "name": "Boss",
      "tags": ["LandUnit"],
      "speed": 3,
      "perception": 1,
      "maxHp": 100,
      "weapons": [
        {
          "name": "BigGun",
          "damage": {"LandUnit": 50, "WaterUnit": 100},
          "minRange": 2,
          "maxRange": 3
        }
      ],
      "abilities": ["BuildBlob", "BuildBoat"],
      "omitBuildAbility": true,
      "rules": [
        {
          "on": "UnitDestroyed",
          "then": "unit.owner.defeated = true"
        }
      ]
    }
  ],
  "redactionPolicy": [
    "// omitted for now"
  ]
}
